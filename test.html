<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Gallery Unit Tests</title>
    <style>
        body {
            font-family: monospace;
            background: #222;
            color: #eee;
            padding: 20px;
        }

        .pass {
            color: #4f4;
        }

        .fail {
            color: #f44;
        }

        .summary {
            margin-top: 20px;
            font-weight: bold;
            font-size: 1.2em;
        }
    </style>
</head>

<body>
    <h1>Running Tests...</h1>
    <div id="output"></div>

    <!-- Load Modules -->
    <script src="js/assetLoader.js"></script>
    <script src="js/gallery.js"></script>
    <script src="js/audioPlayer.js"></script>
    <script src="js/touchControls.js"></script>
    <script src="js/fullscreen.js"></script>

    <script>
        const output = document.getElementById('output');
        let passed = 0;
        let failed = 0;

        function log(msg, isPass) {
            const div = document.createElement('div');
            div.textContent = (isPass ? '[PASS] ' : '[FAIL] ') + msg;
            div.className = isPass ? 'pass' : 'fail';
            output.appendChild(div);
            if (isPass) passed++; else failed++;
        }

        function assert(condition, msg) {
            log(msg, condition);
        }

        // --- Mocks ---
        class MockImage {
            set src(url) {
                setTimeout(() => {
                    if (this.onload) this.onload();
                }, 10);
            }
        }
        window.Image = MockImage;

        class MockAudio {
            load() {
                setTimeout(() => {
                    this.dispatchEvent(new Event('canplaythrough'));
                }, 10);
            }
            addEventListener(event, callback) {
                this['on' + event] = callback;
            }
            removeEventListener() { }
            dispatchEvent(event) {
                if (this['on' + event.type]) this['on' + event.type](event);
            }
        }
        window.Audio = MockAudio;

        async function runTests() {
            console.log("Starting Tests...");

            // --- Test Suite 1: AssetLoader ---
            log("--- AssetLoader Tests ---", true);
            const loader = new AssetLoader({ maxCacheSize: 2 });

            // Test 1.1: Caching & LRU
            await loader.preloadImage('img1.jpg');
            await loader.preloadImage('img2.jpg');
            assert(loader.cache.has('img1.jpg'), 'Image 1 cached');
            assert(loader.cache.has('img2.jpg'), 'Image 2 cached');

            await loader.preloadImage('img3.jpg'); // Should evict img1
            assert(!loader.cache.has('img1.jpg'), 'Image 1 evicted (LRU)');
            assert(loader.cache.has('img3.jpg'), 'Image 3 cached');

            // Test 1.2: Deduplication
            const p1 = loader.preloadImage('img4.jpg');
            const p2 = loader.preloadImage('img4.jpg');
            assert(p1 === p2, 'Duplicate requests return same promise');
            await p1;

            // Test 1.3: Priority Parameter Support
            log("Testing Priority Parameter...", true);
            const priorityLoader = new AssetLoader();

            // Test that priority parameter is accepted (API test)
            const normalPromise = priorityLoader.preloadImage('test1.jpg', 'normal');
            const criticalPromise = priorityLoader.preloadImage('test2.jpg', 'critical');
            const highPromise = priorityLoader.preloadImage('test3.jpg', 'high');

            assert(normalPromise instanceof Promise, 'Priority parameter accepted (normal)');
            assert(criticalPromise instanceof Promise, 'Priority parameter accepted (critical)');
            assert(highPromise instanceof Promise, 'Priority parameter accepted (high)');

            // Test 1.4: Request Cancellation API
            log("Testing Request Cancellation API...", true);
            const cancelLoader = new AssetLoader();

            // Test that cancelPendingRequests method exists and is callable
            assert(typeof cancelLoader.cancelPendingRequests === 'function', 'cancelPendingRequests method exists');

            // Call it with a filter function
            cancelLoader.cancelPendingRequests(() => false);
            assert(true, 'cancelPendingRequests is callable');

            // Test 1.5: Asset State Checking
            log("Testing Asset State API...", true);
            const stateLoader = new AssetLoader();

            // Test getAssetState method
            assert(typeof stateLoader.getAssetState === 'function', 'getAssetState method exists');
            assert(stateLoader.getAssetState('unloaded.jpg') === 'unloaded', 'Unloaded asset state');

            const loadingPromise = stateLoader.preloadImage('loading.jpg');
            assert(stateLoader.getAssetState('loading.jpg') === 'loading', 'Loading asset state');

            await loadingPromise;
            assert(stateLoader.getAssetState('loading.jpg') === 'loaded', 'Loaded asset state');


            // --- Test Suite 2: Gallery Logic ---
            log("--- Gallery Tests ---", true);
            const mockConfig = {
                groups: [
                    { id: 'g1', images: [{ src: 'img1.jpg' }, { src: 'img2.jpg' }], audioSrc: 'audio1.mp3' },
                    { id: 'g2', images: [{ src: 'img3.jpg' }], audioSrc: 'audio2.mp3' }
                ]
            };
            const gallery = new Gallery(mockConfig, loader);

            // Test 2.1: Init & Flattening
            assert(gallery.slides.length === 3, 'Config flattened correctly (3 slides)');
            assert(gallery.getCurrentSlide().src === 'img1.jpg', 'Starts at first slide');

            // Test 2.2: Navigation Boundaries
            assert(gallery.hasPrevious() === false, 'No previous at start');
            assert(gallery.hasNext() === true, 'Has next at start');

            gallery.prev();
            assert(gallery.currentIndex === 0, 'Prev() at start does nothing');

            // Test 2.3: Forward Navigation
            gallery.next();
            assert(gallery.currentIndex === 1, 'Moved to slide 2');
            assert(gallery.getCurrentSlide().src === 'img2.jpg', 'Correct slide content');

            // Manually reset debounce for testing
            gallery.isTransitioning = false;

            gallery.next();
            assert(gallery.currentIndex === 2, 'Moved to slide 3 (Group 2)');
            assert(gallery.getCurrentSlide().groupId === 'g2', 'Group changed to g2');
            assert(gallery.hasNext() === false, 'No next at end');

            // Test 2.4: Backward Navigation
            // Manually reset debounce for testing
            gallery.isTransitioning = false;

            gallery.prev();
            assert(gallery.currentIndex === 1, 'Moved back to slide 2');
            assert(gallery.getCurrentSlide().groupId === 'g1', 'Group changed back to g1');

            // --- Test Suite 3: AudioPlayer ---
            log("--- AudioPlayer Tests ---", true);
            const player = new AudioPlayer();

            player.setVolume(0.8);
            assert(player.volume === 0.8, 'Volume set correctly');

            player.setMuted(true);
            assert(player.isMuted === true, 'Muted is true');
            assert(player.audio.volume === 0, 'Actual audio volume is 0');

            player.setMuted(false);
            assert(player.audio.volume === 0.8, 'Volume restored after unmute');

            // --- Test Suite 4: Fullscreen ---
            log("--- Fullscreen Tests ---", true);
            const fsBtn = document.createElement('button');
            let requestedFs = false;
            let exitedFs = false;

            // Mock Fullscreen API
            const mockRoot = {
                requestFullscreen: () => { requestedFs = true; }
            };
            document.exitFullscreen = () => { exitedFs = true; };

            // Mock document.fullscreenElement property
            Object.defineProperty(document, 'fullscreenElement', {
                get: () => requestedFs && !exitedFs ? mockRoot : null,
                configurable: true
            });

            initFullscreen({
                rootEl: mockRoot,
                fullscreenButtonEl: fsBtn
            });

            // Test Toggle
            fsBtn.click();
            assert(requestedFs === true, 'Request Fullscreen called');

            fsBtn.click();
            assert(exitedFs === true, 'Exit Fullscreen called');

            // --- Summary ---
            const summary = document.createElement('div');
            summary.className = 'summary';
            summary.textContent = `Total: ${passed + failed} | Passed: ${passed} | Failed: ${failed}`;
            document.body.appendChild(summary);
        }

        runTests().catch(e => {
            console.error(e);
            const div = document.createElement('div');
            div.textContent = 'Test Runner Error: ' + e.message;
            div.className = 'fail';
            output.appendChild(div);
        });
    </script>
</body>

</html>